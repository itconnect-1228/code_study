"""LearningDocument model for AI-generated educational content.

This module defines the LearningDocument SQLAlchemy model which stores
the 7-chapter educational content generated by AI for each task.

The model corresponds to the 'learning_documents' table in PostgreSQL and includes:
- UUID primary key for distributed system compatibility
- Task ownership via unique foreign key (one-to-one relationship)
- JSONB content field for storing 7-chapter document structure
- Generation status tracking for async document generation
- Celery task tracking for monitoring async progress

Example:
    from backend.src.models import LearningDocument
    from backend.src.db import get_session_context

    async with get_session_context() as session:
        document = LearningDocument(
            task_id=task.id,
            content={
                "chapter1": {"title": "What This Code Does", "summary": "..."},
                "chapter2": {"title": "Prerequisites", "concepts": [...]},
                "chapter3": {"title": "Code Structure", "flowchart": "..."},
                "chapter4": {"title": "Line-by-Line", "explanations": [...]},
                "chapter5": {"title": "Execution Flow", "steps": [...]},
                "chapter6": {"title": "Core Concepts", "concepts": [...]},
                "chapter7": {"title": "Common Mistakes", "mistakes": [...]}
            },
            generation_status="completed"
        )
        session.add(document)
        await session.commit()
"""

from datetime import UTC, datetime
from typing import Any
from uuid import UUID, uuid4

from sqlalchemy import (
    TIMESTAMP,
    CheckConstraint,
    ForeignKey,
    Index,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.db import Base


class LearningDocument(Base):
    """Generated 7-chapter educational content for a task.

    Represents the AI-generated learning document containing comprehensive
    educational content organized into 7 chapters. Each document is
    generated asynchronously via Celery and stored as JSONB.

    Attributes:
        id: Unique identifier (UUID v4, auto-generated).
        task_id: Foreign key to the task (unique, one-to-one).
        content: JSONB field containing 7-chapter document structure.
        generation_status: Status of document generation
            ('pending', 'in_progress', 'completed', 'failed').
        generation_started_at: When generation began (nullable).
        generation_completed_at: When generation finished (nullable).
        generation_error: Error message if generation failed (nullable).
        celery_task_id: Celery task ID for status tracking (nullable).
        created_at: Document creation timestamp (UTC, auto-set).
        updated_at: Last modification timestamp (UTC, auto-updated).

    Table Constraints:
        - Generation status must be valid (PostgreSQL CHECK)
        - Task foreign key with CASCADE delete
        - Task ID must be unique (one document per task)

    Indexes:
        - idx_learning_documents_task_id: Fast lookup by task
        - idx_learning_documents_status: Filter by generation status
        - idx_learning_documents_celery_task: Lookup by Celery task ID

    JSONB Content Structure:
        {
            "chapter1": {"title": str, "summary": str},
            "chapter2": {"title": str, "concepts": [...]},
            "chapter3": {"title": str, "flowchart": str, "file_breakdown": {...}},
            "chapter4": {"title": str, "explanations": [...]},
            "chapter5": {"title": str, "steps": [...]},
            "chapter6": {"title": str, "concepts": [...]},
            "chapter7": {"title": str, "mistakes": [...]}
        }

    Example:
        document = LearningDocument(
            task_id=task.id,
            content={"chapter1": {...}, ...},
            generation_status="pending"
        )
    """

    __tablename__ = "learning_documents"

    # Primary key - UUID for security and distributed compatibility
    id: Mapped[UUID] = mapped_column(
        primary_key=True,
        default=uuid4,
    )

    # Task relationship (one-to-one, unique constraint)
    task_id: Mapped[UUID] = mapped_column(
        ForeignKey("tasks.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
        index=False,  # We define index separately for naming
    )

    # JSONB content field for 7-chapter document structure
    content: Mapped[dict[str, Any]] = mapped_column(
        JSONB,
        nullable=False,
        default=dict,
    )

    # Generation status tracking
    generation_status: Mapped[str] = mapped_column(
        String(20),
        nullable=False,
        default="pending",
    )

    # Generation timestamps
    generation_started_at: Mapped[datetime | None] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=True,
        default=None,
    )
    generation_completed_at: Mapped[datetime | None] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=True,
        default=None,
    )

    # Error tracking for failed generation
    generation_error: Mapped[str | None] = mapped_column(
        Text,
        nullable=True,
        default=None,
    )

    # Celery task ID for async tracking
    celery_task_id: Mapped[str | None] = mapped_column(
        String(255),
        nullable=True,
        default=None,
    )

    # Timestamp fields (TIMESTAMP WITH TIME ZONE for PostgreSQL)
    created_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        default=lambda: datetime.now(UTC),
    )
    updated_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        default=lambda: datetime.now(UTC),
        onupdate=lambda: datetime.now(UTC),
    )

    # Relationship to Task (for eager loading if needed)
    task = relationship("Task", back_populates="learning_document")

    # Table-level constraints and indexes
    __table_args__ = (
        # Generation status must be valid
        CheckConstraint(
            "generation_status IN ('pending', 'in_progress', 'completed', 'failed')",
            name="valid_generation_status",
        ),
        # Index for task lookup
        Index("idx_learning_documents_task_id", "task_id"),
        # Index for status filtering
        Index("idx_learning_documents_status", "generation_status"),
        # Index for Celery task lookup
        Index("idx_learning_documents_celery_task", "celery_task_id"),
    )

    def __repr__(self) -> str:
        """Return string representation for debugging.

        Returns:
            str: LearningDocument representation with id and status.
        """
        return f"<LearningDocument(id={self.id}, task_id={self.task_id}, status={self.generation_status!r})>"

    def start_generation(self, celery_task_id: str | None = None) -> None:
        """Mark document generation as started.

        Sets generation_status to 'in_progress' and records the start time.
        Optionally stores the Celery task ID for tracking.

        Args:
            celery_task_id: Optional Celery task ID for status tracking.

        Example:
            document.start_generation("celery-task-123")
            await session.commit()
        """
        self.generation_status = "in_progress"
        self.generation_started_at = datetime.now(UTC)
        if celery_task_id:
            self.celery_task_id = celery_task_id

    def complete_generation(self, content: dict[str, Any]) -> None:
        """Mark document generation as completed with content.

        Sets generation_status to 'completed', stores the content,
        and records the completion time.

        Args:
            content: The 7-chapter document content as a dictionary.

        Example:
            document.complete_generation({
                "chapter1": {...},
                "chapter2": {...},
                ...
            })
            await session.commit()
        """
        self.generation_status = "completed"
        self.content = content
        self.generation_completed_at = datetime.now(UTC)

    def fail_generation(self, error_message: str) -> None:
        """Mark document generation as failed with error message.

        Sets generation_status to 'failed' and stores the error message.

        Args:
            error_message: Description of what went wrong during generation.

        Example:
            document.fail_generation("Gemini API rate limit exceeded")
            await session.commit()
        """
        self.generation_status = "failed"
        self.generation_error = error_message
        self.generation_completed_at = datetime.now(UTC)

    @property
    def is_pending(self) -> bool:
        """Check if document generation is pending.

        Returns:
            bool: True if generation hasn't started yet.
        """
        return self.generation_status == "pending"

    @property
    def is_in_progress(self) -> bool:
        """Check if document generation is in progress.

        Returns:
            bool: True if generation is currently running.
        """
        return self.generation_status == "in_progress"

    @property
    def is_completed(self) -> bool:
        """Check if document generation completed successfully.

        Returns:
            bool: True if generation finished successfully.
        """
        return self.generation_status == "completed"

    @property
    def is_failed(self) -> bool:
        """Check if document generation failed.

        Returns:
            bool: True if generation failed.
        """
        return self.generation_status == "failed"

    @property
    def has_content(self) -> bool:
        """Check if document has valid content.

        Returns:
            bool: True if content is not empty and has chapter structure.
        """
        if not self.content:
            return False
        required_chapters = [
            "chapter1", "chapter2", "chapter3", "chapter4",
            "chapter5", "chapter6", "chapter7"
        ]
        return all(chapter in self.content for chapter in required_chapters)

    def get_chapter(self, chapter_number: int) -> dict[str, Any] | None:
        """Get a specific chapter from the document content.

        Args:
            chapter_number: Chapter number (1-7).

        Returns:
            dict or None: The chapter content if it exists, None otherwise.

        Example:
            chapter1 = document.get_chapter(1)
            if chapter1:
                print(chapter1["summary"])
        """
        if not self.content or chapter_number < 1 or chapter_number > 7:
            return None
        return self.content.get(f"chapter{chapter_number}")
